#!/bin/groovy
/*
 * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The OpenAirInterface Software Alliance licenses this file to You under
 * the OAI Public License, Version 1.1  (the "License"); you may not use this file
 * except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.openairinterface.org/?page_id=698
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-------------------------------------------------------------------------------
 * For more information about the OpenAirInterface (OAI) Software Alliance:
 *      contact@openairinterface.org
 */

// Abstraction function to send social media messages:
// like on Slack or Mattermost
// def sendSocialMediaMessage(pipeChannel, pipeColor, pipeMessage) {
//     if (params.pipelineUsesSlack != null) {
//         if (params.pipelineUsesSlack) {
//             slackSend channel: pipeChannel, color: pipeColor, message: pipeMessage
//         }
//     }
// }

// def doFlexranCtrlTest = false

// // Location of the executor node
def nodeExecutor = params.nodeExecutor

// // VM Lockable resources
// def vmResource = params.vmLockableResource

// // Tags to shorten pipeline duration
def doMandatoryTests = false
def doFullTestsuite = false

pipeline {
    //agent {
    //    label nodeExecutor
    //}
    agent any
    options {
        disableConcurrentBuilds()
        timestamps()
        //gitLabConnection('OAI Gitlab fork')
        //ansiColor('xterm')
        //gitlabBuilds(builds: [
         //   "print latest commit info"
            //"Build RHEL8 AMF Image",
            //"Static Code Analysis",
            //"Code Formatting Checker",
            //"Test with DsTester"
        //    ])

    }

    //properties([[$class: 'GitLabConnectionProperty', gitLabConnection: 'OAI GitLab Fork']])

    stages {
        stage ("Display context variables") {
            steps {
                script {
                    //gitlabCommitStatus(name: "Print latest commit info") {
                        echo "Building on: "
                        echo "  Repository -- ${GIT_URL}"
                        echo "  Branch -- ${GIT_BRANCH}"
                        echo "  Commit -- ${GIT_COMMIT}"
                        echo "ENV request type: ${env.gitlabMergeRequestIid}"
                        echo "ENV action type: ${env.gitlabActionType}"
                        echo "ENV branch: ${env.gitlabBranch}"
                        echo "ENV source branch: ${env.gitlabSourceBranch}"
                        echo "ENV target branch: ${env.gitlabTargetBranch}"
                        //sh 'printenv'
                    //}
                }
            }
        }

        stage ("Build in worker job") {
            steps {
                script {
                    triggerWorkerJob ('Open6G Colosseum Worker', 'Test-gNB-nrUE-Band78')
                }
            }
        }
    }
}

// // ----  Worker Job functions

def triggerWorkerJob (jobName, gitlabStatusName) {
    // Workaround for the "cancelled" GitLab pipeline notification
    // The worker job is triggered with the propagate false so the following commands are executed
    // Its status is now PASS/SUCCESS from a stage pipeline point of view
    // localStatus variable MUST be analyzed to properly assess the status
    localStatus = build job: jobName,
        parameters: [
            string(name: 'eNB_Repository', value: String.valueOf(GIT_URL)),
            string(name: 'eNB_Branch', value: String.valueOf(env.gitlabSourceBranch)),
            string(name: 'eNB_CommitID', value: String.valueOf(env.gitlabMergeRequestLastCommit)),
            booleanParam(name: 'eNB_mergeRequest', value: "MERGE".equals(env.gitlabActionType)),
            string(name: 'eNB_TargetBranch', value: String.valueOf(env.gitlabTargetBranch))
        ], propagate: false
    localResult = localStatus.getResult()
    echo "${jobName} Worker Job status is ${localResult}"
    //gitlabCommitStatus(name: gitlabStatusName) {
        if (localStatus.resultIsBetterOrEqualTo('SUCCESS')) {
           echo "${jobName} Worker Job is OK"
        } else {
           echo "${jobName} Worker Job is KO"
           sh "ci-scripts/fail.sh"
        }
    //}
}

// def triggerWorkerJobNoGitLab (jobName) {
//     // Workaround for the "cancelled" GitLab pipeline notification
//     // The worker job is triggered with the propagate false so the following commands are executed
//     // Its status is now PASS/SUCCESS from a stage pipeline point of view
//     // localStatus variable MUST be analyzed to properly assess the status
//     localStatus = build job: jobName,
//         parameters: [
//             string(name: 'eNB_Repository', value: String.valueOf(GIT_URL)),
//             string(name: 'eNB_Branch', value: String.valueOf(env.gitlabSourceBranch)),
//             string(name: 'eNB_CommitID', value: String.valueOf(env.gitlabMergeRequestLastCommit)),
//             booleanParam(name: 'eNB_mergeRequest', value: "MERGE".equals(env.gitlabActionType)),
//             string(name: 'eNB_TargetBranch', value: String.valueOf(env.gitlabTargetBranch))
//         ], propagate: false
//     localResult = localStatus.getResult()
//     echo "${jobName} Worker Job status is ${localResult}"
//     if (localStatus.resultIsBetterOrEqualTo('SUCCESS')) {
//        echo "${jobName} Worker Job is OK"
//     } else {
//        echo "${jobName} Worker Job is KO"
//        sh "ci-scripts/fail.sh"
//     }
// }

def finalizeWorkerJob(jobName) {
    // In case of any non-success, we are retrieving the HTML report of the last completed
    // worker job. The only drop-back is that we may retrieve the HTML report of a previous build
    fileName = "test_results-${jobName}.html"
    if (!fileExists(fileName)) {
        copyArtifacts(projectName: jobName,
            filter: 'test_results*.html',
            selector: lastCompleted())
        if (fileExists(fileName)) {
            sh "sed -i -e 's#TEMPLATE_BUILD_TIME#${JOB_TIMESTAMP}#' ${fileName}"
            archiveArtifacts artifacts: fileName
        }
    }
}
